{"version":3,"sources":["../src/ackmate-parser.js"],"names":[],"mappings":"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","file":"ackmate-parser.js","sourcesContent":["//From https://github.com/alexgorbatchev/ackmate-parser/blob/master/lib/ackmate-parser.js\r\n\r\nimport through2 from 'through2'\r\nimport logger from 'bragi'\r\n\r\nexport default (options = {}) => {\r\n  logger.options.groupsEnabled = options.groupsEnabled || false\r\n  logger.options.groupsDisabled = options.groupsDisabled || true\r\n\r\n  const surroundLine = /^(\\d+):(.*)$/\r\n  const matchLine = /^(\\d+);(\\d+) (\\d+):(.*)$/\r\n  const matchComposeLine = /^(\\d+);(\\d+ \\d+(?:,\\d+ \\d+)*):(.*)$/\r\n  const emptyLine = /^\\s*$/\r\n  const newline = /\\n|\\r\\n/\r\n  let stream = through2.obj(transform, flush)\r\n  let filename = null\r\n  let tail = null\r\n\r\n  function push(data) {\r\n    return stream.push(data)\r\n  }\r\n\r\n  function processLine (line) {\r\n      let index, length, lineNumber, matches, value\r\n\r\n      if (line[0] === ':') {\r\n        logger.log('Parser:processLine', `case filename only`)\r\n        filename = line.slice(1)\r\n      } else if (matches = line.match(surroundLine)) {\r\n        logger.log('Parser:processLine', `case surroundLine`)\r\n        const [,lineNumber, value] = matches\r\n        push({\r\n          filename,\r\n          lineNumber,\r\n          value\r\n        })\r\n      } else if (matches = line.match(matchComposeLine)) {\r\n        logger.log('Parser:processLine', 'case matchComposeLine')\r\n        logger.log('Parser:processLine:debug', matches)\r\n        const [,lineNumber, pairStr, value] = matches\r\n        const pairs = pairStr.split(',')\r\n        pairs.forEach(pair => {\r\n          const [index, length] = pair.split(' ')\r\n          push({\r\n            filename,\r\n            lineNumber,\r\n            index,\r\n            length,\r\n            value\r\n          })\r\n        })\r\n      } else if (emptyLine.test(line)) {\r\n        logger.log('Parser:processLine', `empty line`)\r\n      } else {\r\n        logger.log('Parser:processLine', `unhandled case`)\r\n        logger.log('Parser:processLine:debug', line)\r\n        stream.emit('error', new Error('Invalid case'))\r\n      }\r\n    }\r\n\r\n  function transform(data, encoding, callback) {\r\n    let hasTail, line, lines, _len\r\n\r\n    logger.log('Parser:transform:debug', data.toString())\r\n\r\n    data = data.toString()\r\n    if (tail != null) {\r\n      data = tail + data\r\n    }\r\n    // hasTail = data[data.length - 1] !== '\\n'\r\n    hasTail = !newline.test(data[data.length - 1])\r\n    lines = data.split(newline)\r\n    tail = hasTail && lines.pop() || null\r\n    lines.forEach(line => processLine(line))\r\n    return callback()\r\n  }\r\n\r\n  function flush(callback) {\r\n    if (tail != null) {\r\n      logger.log('Parser:flush:debug', `tail`, tail)\r\n      processLine(tail)\r\n    }\r\n    logger.log('Parser:flush:debug')\r\n    return callback()\r\n  }\r\n\r\n  return stream\r\n}\r\n"]}